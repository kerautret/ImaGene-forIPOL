//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// File name : IntegerComputer.ih
//
// Creation : 2011/01/10
//
// Version : 2011/01/10
//
// Author : JOL
//          EC (COBA algorithm)
//
// Summary : Implementation of inline methods defined in IntegerComputer.h 
//
// History :
//	2011/01/10 : ?Name? : ?What?
//
// Rcs Id : "@(#)class IntegerComputer declaration."
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
#include <iostream>
//////////////////////////////////////////////////////////////////////////////

#if defined(NO_DEBUG)
#define ASSERT_IntegerComputer(x)
#define DEBUGCMD_IntegerComputer(x)
#else //defined(NO_DEBUG)
#define ASSERT_IntegerComputer(x) if(!(x)) \
    { std::cerr << "Assertion failed : (" << #x << ')' << std::endl \
    << "In file : " << __FILE__ << " at line #" << __LINE__ << std::endl \
    << "Compiled the " << __DATE__ << " at " << __TIME__ << std::endl; abort();}
#define DEBUGCMD_IntegerComputer(x) x
#endif // else defined(NO_DEBUG)

///////////////////////////////////////////////////////////////////////////////
// Implementation of inline methods                                          //

//-----------------------------------------------------------------------------
//////////////////////////////// Integer //////////////////////////////////////
//-----------------------------------------------------------------------------
// inline
// std::ostream & 
// ImaGene::operator<<( std::ostream & out, const Integer & a )
// {
//   out << a;
//   return out;
// }
//-----------------------------------------------------------------------------
//////////////////////////////// Internal //////////////////////////////////////
//-----------------------------------------------------------------------------
inline
ImaGene::Integer
ImaGene::_abs(const Integer & a )            
{ 
  if ( a >= I_ZERO ) return a; 
  return -a;
}
//-----------------------------------------------------------------------------
inline
ImaGene::Integer
ImaGene::_max( const Integer & a, const Integer & b) 
{ 
  return ( a < b ) ? b : a;
}
//-----------------------------------------------------------------------------
inline
ImaGene::Integer
ImaGene::_min( const Integer & a,const Integer & b) 
{
  return ( a < b ) ? a : b;
}
//-----------------------------------------------------------------------------
inline
ImaGene::Integer
ImaGene::_floordiv( const Integer &na, const Integer &nb )
{
  Integer a( na );
  Integer b( nb );
  if( ( a < I_ZERO ) && ( b < I_ZERO ) )
    {
      a=-a;
      b=-b;
    }
  else if( b < I_ZERO )
    {
      a=-a;
      b=-b;
    }
  if(( a > I_ZERO ) || (a % b == I_ZERO ))
    return a/b;
  else
    return a/b - I_ONE;
}
//-----------------------------------------------------------------------------
inline
ImaGene::Integer
ImaGene::_ceildiv( const Integer & na, const Integer & nb )
{
  Integer a( na );
  Integer b( nb );
  if( ( a < I_ZERO ) && ( b < I_ZERO ) )
    {
      a=-a;
      b=-b;
    }
  else if( b < I_ZERO )
    {
      a=-a;
      b=-b;
    }
  
  if( ( a < I_ZERO ) || ( a % b == I_ZERO) )
    return a/b;
  else
    return ( a/b + I_ONE );
}
//-----------------------------------------------------------------------------
inline
ImaGene::Integer
ImaGene::_gcd( const Integer & a, const Integer & b )
{
  //  std::cerr << "gcd(" << a << ", " << b << ")=";
  Integer aa( _abs( a ) );
  Integer bb( _abs( b ) );
  Integer a0( _max( aa, bb ) );
  Integer a1( _min( aa, bb ) );
  Integer r;
  while ( a1 != I_ZERO )
  {
    r = a0 % a1;
    a0 = a1;
    a1 = r;
  }
  return a0;
}
//-----------------------------------------------------------------------------
//////////////////////////////// Point2I //////////////////////////////////////
//-----------------------------------------------------------------------------
inline
ImaGene::Point2I::Point2I()
  : x( I_ZERO ), y( I_ZERO )
{}
//-----------------------------------------------------------------------------
inline
ImaGene::Point2I::Point2I(const Point2I &A)
  : x( A.x ), y( A.y )
{}
//-----------------------------------------------------------------------------
inline
ImaGene::Point2I::Point2I(const Integer & a, const Integer & b)
  : x( a ), y( b )
{}
//-----------------------------------------------------------------------------
inline
ImaGene::Point2I& 
ImaGene::Point2I::operator =( const Point2I &A )
{
  if ( this != &A )
    {
      x = A.x;
      y = A.y;  
    }
  return *this; 
}
//-----------------------------------------------------------------------------
inline
void 
ImaGene::Point2I::reduce()
{
  Integer p = _gcd(x,y);
  x = x / p;
  y = y / p;
}
//-----------------------------------------------------------------------------
inline
void 
ImaGene::Point2I::neg()
{
  x = -x;
  y = -y;
}
//-----------------------------------------------------------------------------
inline
void 
ImaGene::Point2I::rnd( int lg_max )
{
  do
    {
      x = ( random() % (lg_max*2+1) ) - lg_max;
      y = ( random() % (lg_max*2+1) ) - lg_max;
    } 
  while ( ( x == I_ZERO ) && ( y == I_ZERO ) );
}
//-----------------------------------------------------------------------------
inline
ImaGene::Point2I &
ImaGene::Point2I::operator+= ( const Point2I & A )
{
  x += A.x;
  y += A.y;
  return *this;
}
//-----------------------------------------------------------------------------
inline
ImaGene::Point2I &
ImaGene::Point2I::operator-= ( const Point2I & A )
{
  x -= A.x;
  y -= A.y;
  return *this;
}
//-----------------------------------------------------------------------------
inline
ImaGene::Point2I &
ImaGene::Point2I::operator*= ( const Integer & B )
{
  x *= B;
  y *= B;
  return *this;
}
//-----------------------------------------------------------------------------
inline
ImaGene::Point2I &
ImaGene::Point2I::operator/= ( const Integer & B )
{
  x /= B;
  y /= B;
  return *this;
}
//-----------------------------------------------------------------------------
inline
ImaGene::Point2I
ImaGene::operator+ ( const Point2I & A, const Point2I & B )
{
  return Point2I( A.x + B.x, A.y + B.y );
}
//-----------------------------------------------------------------------------
inline
ImaGene::Point2I
ImaGene::operator- ( const Point2I & A, const Point2I & B )
{
  return Point2I( A.x - B.x, A.y - B.y );
}
//-----------------------------------------------------------------------------
inline
ImaGene::Point2I
ImaGene::operator* ( const Point2I & A, const Integer & B )
{
  return Point2I( A.x * B, A.y * B );
}
//-----------------------------------------------------------------------------
inline
ImaGene::Point2I
ImaGene::operator* ( const Integer & B, const Point2I & A )
{
  return Point2I( A.x * B, A.y * B );
}
//-----------------------------------------------------------------------------
inline
ImaGene::Integer
ImaGene::operator^ ( const Point2I & A, const Point2I & B )
{
  return A.x * B.y - B.x * A.y; 
}
//-----------------------------------------------------------------------------
inline
ImaGene::Integer
ImaGene::operator* ( const Point2I & A, const Point2I & B )
{
  return A.x * B.x + A.y * B.y; 
}
//-----------------------------------------------------------------------------
inline
bool 
ImaGene::operator==( const Point2I & A, const Point2I & B )
{
  return ( A.x == B.x ) && ( A.y == B.y );
}
//-----------------------------------------------------------------------------
inline
bool 
ImaGene::operator!=( const Point2I & A, const Point2I & B )
{
  return ( A.x != B.x ) || ( A.y != B.y );
}
//-----------------------------------------------------------------------------
inline
std::ostream & 
ImaGene::operator<<( std::ostream & out, const Point2I & a )
{
  out << "(" << a.x << "," << a.y << ")";
  return out;
}

//-----------------------------------------------------------------------------
//////////////////////////////// Point3I //////////////////////////////////////
//-----------------------------------------------------------------------------
inline
ImaGene::Point3I::Point3I() 
  : x( I_ZERO ), y( I_ZERO ), z( I_ZERO )
{}
//-----------------------------------------------------------------------------
inline
ImaGene::Point3I::Point3I( const Point3I & t )
  : x( t.x ), y( t.y ), z( t.z )
{}
//-----------------------------------------------------------------------------
inline
ImaGene::Point3I & 
ImaGene::Point3I::operator=( const Point3I & A )   
{
  if ( this != &A )
    {
      x = A.x; 
      y = A.y; 
      z = A.z; 
    }
  return * this; 
}
//-----------------------------------------------------------------------------
inline
ImaGene::Point3I::Point3I( const Integer & _x, 
			   const Integer & _y, 
			   const Integer & _z )
  : x( _x ), y( _y ), z( _z )
{}
//-----------------------------------------------------------------------------
inline
void 
ImaGene::Point3I::reduce()
{
  Integer p = _gcd(x,y);
  p = _gcd(p,z);
  x = x / p;
  y = y / p;
  z = z / p;
}
//-----------------------------------------------------------------------------
inline
void 
ImaGene::Point3I::neg()
{
  x = -x;
  y = -y;
  z = -z;
}
//-----------------------------------------------------------------------------
inline
ImaGene::Point3I
ImaGene::operator+ ( const Point3I & a, const Point3I & b )
{
  return Point3I( a.x + b.x, a.y + b.y, a.z + b.z );
}
//-----------------------------------------------------------------------------
inline
ImaGene::Point3I 
ImaGene::operator- (const Point3I & a, const Point3I & b)
{
  return Point3I( a.x - b.x, a.y - b.y, a.z - b.z );
}
//-----------------------------------------------------------------------------
inline
ImaGene::Point3I 
ImaGene::operator^ (const Point3I & a, const Point3I & b)
{
  return Point3I( a.y * b.z - a.z * b.y,
		  a.z * b.x - a.x * b.z,
		  a.x * b.y - a.y * b.x );
}
//-----------------------------------------------------------------------------
inline
ImaGene::Integer
ImaGene::operator* (const Point3I & a, const Point3I & b)
{
  return a.x * b.x + a.y * b.y + a.z * b.z;
}
//-----------------------------------------------------------------------------
inline
ImaGene::Point3I 
ImaGene::operator* (const Integer & a, const Point3I & b)
{
  return Point3I( b.x * a, b.y * a, b.z * a );
}
//-----------------------------------------------------------------------------
inline
ImaGene::Point3I
ImaGene::operator* (const Point3I & b, const Integer & a)
{
  return Point3I( b.x * a, b.y * a, b.z * a );
}
//-----------------------------------------------------------------------------
inline
ImaGene::Point3I
ImaGene::operator/ (const Point3I & b, const Integer & a)
{
  return Point3I( b.x / a, b.y / a, b.z / a );
}
//-----------------------------------------------------------------------------
inline
bool
ImaGene::operator== ( const Point3I & a, const Point3I & b )
{
  return ( a.x == b.x ) && ( a.y == b.y ) && ( a.z == b.z );
}
//-----------------------------------------------------------------------------
inline
bool
ImaGene::operator!= ( const Point3I & a, const Point3I & b )
{
  return ( a.x != b.x ) || ( a.y != b.y ) || ( a.z != b.z );
}
//-----------------------------------------------------------------------------
inline
std::ostream & 
ImaGene::operator<<( std::ostream & out, const Point3I & a )
{
  out << "(" << a.x << "," << a.y << "," << a.z << ")";
  return out;
}

//-----------------------------------------------------------------------------
///////////////////////////// IntegerComputer  ////////////////////////////////
//-----------------------------------------------------------------------------
inline
ImaGene::Integer
ImaGene::IntegerComputer::floordiv
( const Integer & na, const Integer & nb ) const
{
  _fda = na;
  _fdb = nb;
  if( ( _fda < I_ZERO ) && ( _fdb < I_ZERO ) )
    {
      _fda=-_fda;
      _fdb=-_fdb;
    }
  else if( _fdb < I_ZERO )
    {
      _fda=-_fda;
      _fdb=-_fdb;
    }
  if(( _fda > I_ZERO ) || (_fda % _fdb == I_ZERO ))
    return _fda/_fdb;
  else
    return _fda/_fdb - I_ONE;
}
//-----------------------------------------------------------------------------
inline
ImaGene::Integer
ImaGene::IntegerComputer::ceildiv
( const Integer & na, const Integer & nb ) const
{
  _cda = na;
  _cdb = nb;
  if( ( _cda < I_ZERO ) && ( _cdb < I_ZERO ) )
    {
      _cda=-_cda;
      _cdb=-_cdb;
    }
  else if( _cdb < I_ZERO )
    {
      _cda=-_cda;
      _cdb=-_cdb;
    }
  
  if( ( _cda < I_ZERO ) || ( _cda % _cdb == I_ZERO) )
    return _cda/_cdb;
  else
    return ( _cda/_cdb + I_ONE );
}
//-----------------------------------------------------------------------------
inline
ImaGene::Integer
ImaGene::IntegerComputer::gcd( const Integer & a, const Integer & b ) const
{
  //  std::cerr << "gcd(" << a << ", " << b << ")=";
  _gaa = _abs( a );
  _gbb = _abs( b );
  _ga0 = _max( _gaa, _gbb );
  _ga1 = _min( _gaa, _gbb );
  while ( _ga1 != I_ZERO )
  {
    _gr = _ga0 % _ga1;
    _ga0 = _ga1;
    _ga1 = _gr;
  }
  return _ga0;
}
//-----------------------------------------------------------------------------
inline
void
ImaGene::IntegerComputer::gcd
( Integer & g,
  const Integer & a, const Integer & b ) const
{
  //  std::cerr << "gcd(" << a << ", " << b << ")=";
  _gaa = _abs( a );
  _gbb = _abs( b );
  _ga0 = _max( _gaa, _gbb );
  _ga1 = _min( _gaa, _gbb );
  while ( _ga1 != I_ZERO )
  {
    _gr = _ga0 % _ga1;
    _ga0 = _ga1;
    _ga1 = _gr;
  }
  g = _ga0;
}
//-----------------------------------------------------------------------------
inline
ImaGene::Integer
ImaGene::IntegerComputer::cfrac
( std::vector<Integer> & quotients,
  const Integer & a, const Integer & b ) const
{
  _ga0 = a;
  _ga1 = b;
  while ( _ga1 != I_ZERO )
  {
    quotients.push_back( _ga0 / _ga1 );
    _gr = _ga0 % _ga1;
    _ga0 = _ga1;
    _ga1 = _gr;
  }
  return _ga0;
}
//-----------------------------------------------------------------------------
inline
void
ImaGene::IntegerComputer::reduce( Point2I & p ) const
{
  _rt = gcd( _abs( p.x ), _abs( p.y ) );
  if ( ( _rt != I_ONE ) && ( _rt != I_ZERO ) )
    {
      p.x = p.x / _rt;
      p.y = p.y / _rt;
    }
}
//-----------------------------------------------------------------------------
inline
ImaGene::Integer 
ImaGene::IntegerComputer::cross_product
( const Point2I & u, const Point2I & v) const
{
  _cp1 = u.x * v.y;
  _cp2 = u.y * v.x;
  return _cp1 - _cp2;
}
//-----------------------------------------------------------------------------
inline
void
ImaGene::IntegerComputer::cross_product
( Integer & cp, const Point2I & u, const Point2I & v) const
{
  _cp1 = u.x * v.y;
  _cp2 = u.y * v.x;
  cp = _cp1 - _cp2;
}
//-----------------------------------------------------------------------------
inline
ImaGene::Integer
ImaGene::IntegerComputer::dot_product
( const Point2I & u, const Point2I & v ) const
{
  _dp1 = u.x * v.x;
  _dp2 = u.y * v.y;
  return _dp1 + _dp2;
}
//-----------------------------------------------------------------------------
inline
void
ImaGene::IntegerComputer::dot_product
( Integer & dp, const Point2I & u, const Point2I & v) const
{
  _dp1 = u.x * v.x;
  _dp2 = u.y * v.y;
  dp = _dp1 + _dp2;
}
//-----------------------------------------------------------------------------
inline
void
ImaGene::IntegerComputer::dot_product
( Integer & dp, const Point3I & u, const Point3I & v) const
{
  dp =  u.x * v.x;
  dp += u.y * v.y;
  dp += u.z * v.z;
}
//-----------------------------------------------------------------------------
inline
void 
ImaGene::IntegerComputer::coefficientIntersection
( const Point2I & p, 
  const Point2I & u, const Point2I & N, 
  const Integer & c,
  Integer & fl, Integer & ce ) const
{
  dot_product( _ci1, p, N );
  dot_product( _ci2, u, N );
  _ci3 = c - _ci1;
  fl = floordiv( _ci3, _ci2 );
  ce = ceildiv( _ci3, _ci2 );
}
//-----------------------------------------------------------------------------
inline
void 
ImaGene::IntegerComputer::validBezout
( const Point2I & A, const Point2I & u,
  Point2I & v, const Point2I & N, 
  const Integer & c, const Point2I & N2, 
  const Integer & c2, int redef ) const
{
  if ( redef == 1 )
    {
      v = ExtendedEuclid( -u.y, u.x, I_ONE );
      _vbp1 = A + v;
      _vbi1 = dot_product( _vbp1, N );
      if ( _vbi1 > c )
	{
	  v.x = -v.x;
	  v.y = -v.y;
	}
    }
  _vbp1 = A + v;
  coefficientIntersection( _vbp1, u, N2, c2, _vbfl, _vbce );
  _vbp2 = u * _vbfl;
  v += _vbp2;
}



///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions and external operators                 //

/**
 * Overloads 'operator<<' for displaying objects of class 'IntegerComputer'.
 * @param that_stream the output stream where the object is written.
 * @param that_object_to_display the object of class 'IntegerComputer' to write.
 * @return the output stream after the writing.
 */
std::ostream&
ImaGene::operator<<( std::ostream & that_stream, 
		 const IntegerComputer & that_object_to_display )
{
  that_object_to_display.selfDisplay( that_stream );
  return that_stream;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


