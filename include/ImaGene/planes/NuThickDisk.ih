//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// File name : NuThickDisk.ih
//
// Creation : 2011/01/13
//
// Version : 2011/01/13
//
// Author : JOL
//
// Summary : Implementation of inline methods defined in NuThickDisk.h 
//
// History :
//	2011/01/13 : ?Name? : ?What?
//
// Rcs Id : "@(#)class NuThickDisk declaration."
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
#include <cmath>
#include <iostream>
#include "ImaGene/mathutils/Mathutils.h"
//////////////////////////////////////////////////////////////////////////////

#define BETTER 1
#define WORSE 0
#define END 2

#if defined(NO_DEBUG)
#define ASSERT_NuThickDisk(x)
#define DEBUGCMD_NuThickDisk(x)
#else //defined(NO_DEBUG)
#define ASSERT_NuThickDisk(x) if(!(x)) \
    { std::cerr << "Assertion failed : (" << #x << ')' << std::endl \
    << "In file : " << __FILE__ << " at line #" << __LINE__ << std::endl \
    << "Compiled the " << __DATE__ << " at " << __TIME__ << std::endl; abort();}
#define DEBUGCMD_NuThickDisk(x) x
#endif // else defined(NO_DEBUG)

///////////////////////////////////////////////////////////////////////////////
// Implementation of inline methods                                          //

//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
double
ImaGene::NuThickDisk<TDigitalGraph>::distance
( const Point3i & p1, const Point3i & p2 )
{
  return std::sqrt( Mathutils::sqr( (double) ( p1[ 0 ] - p2[ 0 ] ) ) 
		    + Mathutils::sqr( (double) ( p1[ 1 ] - p2[ 1 ] ) )
		    + Mathutils::sqr( (double) ( p1[ 2 ] - p2[ 2 ] ) ) );
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
ImaGene::NuThickDisk<TDigitalGraph>::~NuThickDisk()
{
  // for ( unsigned int i = 0; i < 3; ++i )
  //   if ( myComputer[ i ] != 0 ) delete myComputer[ i ];
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
ImaGene::NuThickDisk<TDigitalGraph>::NuThickDisk()
{
  myDGraph = 0;
  myThickness = -2.0;
  myMajorAxis = -1;
  for ( unsigned int i = 0; i < 3; ++i )
    {
      myComputer[ i ] = CowPtr<Computer>( new Computer );
      Computer & computer = *(myComputer[ i ]);
      computer.radius = 0.0;
      computer.limit_radius = 0.0;
      computer.finished = false;
    }
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
ImaGene::NuThickDisk<TDigitalGraph>::NuThickDisk
( const NuThickDisk & other )
  : myDGraph( other.myDGraph ), myDist( other.myDist ), myVtx( other.myVtx ),
    myPt( other.myPt ), myThickness( other.myThickness ), 
    myMajorAxis( other.myMajorAxis )
{
  for ( unsigned int i = 0; i < 3; ++i )
    myComputer[ i ] = other.myComputer[ i ];
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
ImaGene::NuThickDisk<TDigitalGraph> &
ImaGene::NuThickDisk<TDigitalGraph>::operator=( const NuThickDisk & other )
{
  myDGraph = other.myDGraph;
  myDist = other.myDist;
  myVtx = other.myVtx;
  myPt = other.myPt;
  myThickness = other.myThickness;
  myMajorAxis = other.myMajorAxis;
  for ( unsigned int i = 0; i < 3; ++i )
    myComputer[ i ] = other.myComputer[ i ];
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
void
ImaGene::NuThickDisk<TDigitalGraph>::init
( const DigitalGraph & dgraph, const Vertex & p, double thickness )
{
  myMajorAxis = 0;
  myDGraph = &dgraph;
  myDist = EuclideanDigitalDistance( myDGraph->dim() );
  myVtx = p;
  myThickness = thickness;
  myDGraph->embed( myVtx, myPt.data() );
  int diameter = myDGraph->diameter();
  for ( unsigned int i = 0; i < 3; ++i )
    {
      Computer & computer = *(myComputer[ i ]);
      computer.radius = 0.0;
      computer.limit_radius = 0.0;
      computer.coba.clear();
      computer.expander.init( *myDGraph, myVtx, myDist );
      computer.coba.init( i, diameter, myThickness, myPt ); 
      computer.finished = false;
    }
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
void
ImaGene::NuThickDisk<TDigitalGraph>::init
( const Vertex & p, const NuThickDisk<DigitalGraph> & disk )
{
  ASSERT_NuThickDisk( false 
		      && "ALERT: should be adapted to only one major axis" );
  myDGraph = disk.myDGraph;
  myDist = disk.myDist;
  myVtx = p;
  myThickness = disk.myThickness;
  myDGraph->embed( myVtx, myPt.data() );
  //  ASSERT_NuThickDisk( myDist.distance( myPt, disk.myPt ) <= disk.radius() );
  for ( unsigned int i = 0; i < 3; ++i )
    {
      Computer & computer = *( myComputer[ i ] );
      const Computer & other_computer = *( disk.myComputer[ i ] );
      computer.radius = other_computer.radius;
      computer.limit_radius = other_computer.limit_radius;
      computer.expander = other_computer.expander;
      computer.expander.reinit( myVtx );
      computer.coba = other_computer.coba;
      computer.finished = false;
    }
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
bool
ImaGene::NuThickDisk<TDigitalGraph>::computeDisk
( double radius_upper_bound )
{
  ASSERT_NuThickDisk( myDGraph != 0 );
  unsigned int pref_axis = myDGraph->preferredAxis( myVtx );
  if ( ! myComputer[ pref_axis ]->finished )
    myComputer[ pref_axis ]->finished = 
      computeForAxis( pref_axis, radius_upper_bound );
  myMajorAxis = pref_axis;
  return myComputer[ pref_axis ]->finished;

  // for ( unsigned int i = 0; i < 3; ++i )
  //   if ( ! myComputer[ i ]->finished )
  //     myComputer[ i ]->finished = computeForAxis( i, radius_upper_bound );
  // bool maximal = myComputer[ 0 ]->finished
  //   && myComputer[ 1 ]->finished
  //   && myComputer[ 2 ]->finished;
  // // greatest radius is major axis.
  // myMajorAxis = 0;
  // if ( ( myComputer[ 1 ]->radius > myComputer[ myMajorAxis ]->radius )
  //      || ( ( myComputer[ 1 ]->radius == myComputer[ myMajorAxis ]->radius )
  // 	    && ( pref_axis == 1 ) ) )
  //   myMajorAxis = 1;
  // if ( ( myComputer[ 2 ]->radius > myComputer[ myMajorAxis ]->radius )
  //      || ( ( myComputer[ 2 ]->radius == myComputer[ myMajorAxis ]->radius )
  // 	    && ( pref_axis == 2 ) ) )
  //   myMajorAxis = 2;
  // return maximal;
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
void
ImaGene::NuThickDisk<TDigitalGraph>::refineNormal
()
{
  unsigned int pref_axis = myDGraph->preferredAxis( myVtx );
  double newWidth, bestWidth;
  Integer maxValue;
  Computer & computer = *(myComputer[ pref_axis ]);
  computer.finished = false;
  
  COBAAlgorithm::State saveState;
  computer.coba.getState( saveState );
  
  bestWidth = computer.coba.thickness();;       
  newWidth = computer.coba.refineNormal();
  // main loop. Save state at each better normal vector
  // stops when when no better normal vector can be found
  // JOL: decreasing sequence must be strict.
  while( ( newWidth != -1 ) && ( newWidth < bestWidth ) )
    {
      //save state
      computer.coba.getState( saveState );
      bestWidth = newWidth;
      newWidth = computer.coba.refineNormal();
    }
  // while ( newWidth != -1 )
  //   {
  // 	  if (newWidth <= bestWidth)
  // 	  {
  // 	    //save state
  // 	    computer.coba.getState( saveState );
  // 	    bestWidth = newWidth;
  // 	  }
  // 	  newWidth = computer.coba.refineNormal();
  //   }

   computer.coba.setState( saveState );
   myComputer[ pref_axis ]->finished = true;
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
void
ImaGene::NuThickDisk<TDigitalGraph>::
optimizeBand()
{
  myComputer[ myMajorAxis ]->coba.optimizeBand();
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
bool
ImaGene::NuThickDisk<TDigitalGraph>::
isInBand( const Vertex & v ) const
{
  Point3i pt;
  myDGraph->embed( v, pt.data() );
  return myComputer[ myMajorAxis ]->coba.check( pt );
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
template <typename VertexIterator>
inline
bool
ImaGene::NuThickDisk<TDigitalGraph>::
areInBand( VertexIterator it, VertexIterator it_end ) const
{
  for ( ; it != it_end; ++it )
    if ( ! isInBand( *it ) )
      return false;
  return true;
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
bool
ImaGene::NuThickDisk<TDigitalGraph>::computeForAxis
( unsigned int axis, double radius_upper_bound )
{
  // std::cerr << "(" << myPt[ 0 ] << "," << myPt[ 1 ] << "," << myPt[ 2 ] << ")I";
  Computer & computer = *(myComputer[ axis ]);
  // explored and in queue vertices.
  // computer.expander.init( *myDGraph, myVtx, myDist );
  bool failOnce = false; //did the reco algorithm fail once?
  Point3i pt;
  Vertex bel = myVtx;

  // main loop. Save state at each new distance.
  COBAAlgorithm::State saveRingState;
  //  computer.coba.getState( saveRingState );
  double currentradius = computer.radius; //radius of the current disk
  typedef std::deque<WeightedVertex> Ring;
  typedef typename std::deque<WeightedVertex>::const_iterator RingConstIterator;
  typedef std::back_insert_iterator< Ring > RingInserter;
  std::deque<WeightedVertex> new_ring;
  while( ! failOnce && ! computer.expander.finished() )
    {
      if ( ( radius_upper_bound >= 0.0 )
	   && ( computer.expander.next().weight > radius_upper_bound ) )
	break;
      computer.coba.getState( saveRingState );
      double previousradius = currentradius; //radius of the preceeding disk
      currentradius = computer.expander.next().weight;
      computer.expander.expandNoGreaterThan( currentradius,
					     RingInserter( new_ring ) );
      // Checks if the next ring induces a valid plane for the given thickness.
      for ( RingConstIterator it = new_ring.begin();
	    it != new_ring.end();
	    ++it )
	{
	  myDGraph->embed( it->cell, pt.data() );
	  if ( ! computer.coba.add( pt, true ) ){
	    failOnce = true;
	    //std::cerr << "break: " << pt <<  std::endl; 
	    break;
	  }
	}
      

      if ( failOnce )
	{
	  currentradius = previousradius;
	  // go back to last meaningful state.
	  computer.coba.setState( saveRingState );
	  computer.expander.pushAgain( new_ring.begin(), new_ring.end() );
	}
      else{
	new_ring.clear();
	// computer.expander.valideExpandCurrentSet();
      }
     } // while( ! failOnce && ! expander.empty() )
  // at this point, the COBA algorithm is in a meaningful state.
  // std::cerr << "=>" << currentradius << std::endl;
  computer.radius = currentradius;
  computer.limit_radius = failOnce 
    ? computer.expander.next().weight
    : currentradius;
  return failOnce || computer.expander.finished();
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
void
ImaGene::NuThickDisk<TDigitalGraph>::
computeExtension( Set & vertices )
{
  Point3i pt;
  Computer & computer = *( myComputer[ majorAxis() ] );
  Expander & expander = computer.expander; 
  // copy explored vertices into the set
  vertices.clear();
  typename Expander::MarkedSet::const_iterator itb = 
    expander.exploredVertices().begin();
  typename Expander::MarkedSet::const_iterator ite = 
    expander.exploredVertices().end();
  for ( ; itb != ite; ++itb ) vertices += *itb;
  WeightedVertex wvtx;
  refineNormal();
  computer.coba.optimizeBand();
  while( ! expander.finished() )
    {
      //extract a surfel
      wvtx = expander.next();
      myDGraph->embed( wvtx.cell, pt.data() );
      // tests if it still corresponds to a digital plane
      //if ( ! computer.coba.add( pt, false ) )
      if ( ! computer.coba.check( pt ) )
	{
	  vertices -= wvtx.cell;
	  expander.ignoreNext();
	}
      else
	{
	  vertices += wvtx.cell;
	  expander.expandNext();
	}
    }
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
void
ImaGene::NuThickDisk<TDigitalGraph>::
computeMaximalPlane( Set & maximal_plane, Set & core )
{
  NuThickDisk<DigitalGraph> disk;
  Point3i pt;
  Computer & computer = *( myComputer[ majorAxis() ] );
  // Start again to find the core.
  Expander expander;
  expander.init( *myDGraph, myVtx, myDist );
  // expander.expandNext();
  // core += myVtx;

  WeightedVertex wvtx;
  while( ! expander.finished() )
    {
      //extract a surfel
      wvtx = expander.next();
      myDGraph->embed( wvtx.cell, pt.data() );
      // tests if it still corresponds to a digital plane
      bool is_in_max_plane = false;
      if ( computer.coba.check( pt ) )
	{
	  // Check if whole disk is inside band.  NB: JOL works very
	  // well with myVtx instead of wvtx.cell, but does not
	  // distinguish between tangency and within-slice.
	  disk.init( *myDGraph, wvtx.cell, myThickness );
	  disk.computeDisk( -1.0 );
	  if ( disk.radius() <= this->limitRadius() )
	    //if ( disk.radius() < this->radius() )
	    {
	      const Set disk_vertices = disk.diskVertices();
	      is_in_max_plane = this->areInBand( disk_vertices.begin(),
						 disk_vertices.end() );
	      if ( is_in_max_plane ) 
		{
		  core += wvtx.cell;
		  for ( typename Set::const_iterator
			  it = disk_vertices.begin(),
			  it_end =  disk_vertices.end(); it != it_end; ++it )
		    maximal_plane += *it;
		  expander.expandNext();
		}
	    }
	}
      if ( ! is_in_max_plane ) 
	expander.ignoreNext();
    }
  //  std::cerr << "  after=" << vertices.size() << std::endl;
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
template <typename VertexSet>
inline
void
ImaGene::NuThickDisk<TDigitalGraph>::
computeMaximalPlane( Set & maximal_plane, Set & core, 
		     const VertexSet & all_cores )
{
  NuThickDisk<DigitalGraph> disk;
  Point3i pt;
  Computer & computer = *( myComputer[ majorAxis() ] );
  // Start again to find the core.
  Expander expander;
  expander.init( *myDGraph, myVtx, myDist );
  // expander.expandNext();
  // core += myVtx;

  WeightedVertex wvtx;
  while( ! expander.finished() )
    {
      //extract a surfel
      wvtx = expander.next();
      bool is_in_max_plane = false;
      if ( all_cores.find( wvtx.cell ) == all_cores.end() )
	{
	  myDGraph->embed( wvtx.cell, pt.data() );
	  // tests if it still corresponds to a digital plane
	  if ( computer.coba.check( pt ) )
	    {
	      // Check if whole disk is inside band.  NB: JOL works very
	      // well with myVtx instead of wvtx.cell, but does not
	      // distinguish between tangency and within-slice.
	      disk.init( *myDGraph, wvtx.cell, myThickness );
	      disk.computeDisk( -1.0 );
	      if ( disk.radius() <= this->limitRadius() )
		//if ( disk.radius() < this->radius() )
		{
		  const Set disk_vertices = disk.diskVertices();
		  is_in_max_plane = this->areInBand( disk_vertices.begin(),
						     disk_vertices.end() );
		  if ( is_in_max_plane ) 
		    {
		      core += wvtx.cell;
		      for ( typename Set::const_iterator
			      it = disk_vertices.begin(),
			      it_end =  disk_vertices.end(); it != it_end; ++it )
			maximal_plane += *it;
		      expander.expandNext();
		    }
		}
	    }
	} //       if ( all_cores.find( wvtx ) == all_cores.end() )
      if ( ! is_in_max_plane ) 
	expander.ignoreNext();
    }
  //  std::cerr << "  after=" << vertices.size() << std::endl;
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
template <typename VertexSet>
inline
void
ImaGene::NuThickDisk<TDigitalGraph>::
computeMaximalPlane( Set & maximal_plane, Set & core, 
		     const VertexSet & all_cores, 
		     std::map<Vertex, double> & map_vtx2radius )
{
  NuThickDisk<DigitalGraph> disk;
  Point3i pt;
  Computer & computer = *( myComputer[ majorAxis() ] );
  // Start again to find the core.
  Expander expander;
  expander.init( *myDGraph, myVtx, myDist );
  // expander.expandNext();
  // core += myVtx;
  typedef std::deque<WeightedVertex> Ring;
  typedef std::back_insert_iterator< Ring > RingInserter;
  
  WeightedVertex wvtx;
  Expander expander2;
  std::deque<WeightedVertex> new_ring;
  while( ! expander.finished() )
    {
      //extract a surfel
      wvtx = expander.next();
      bool is_in_max_plane = false;
      if ( all_cores.find( wvtx.cell ) == all_cores.end() )
	{
	  myDGraph->embed( wvtx.cell, pt.data() );
	  // tests if it still corresponds to a digital plane
	  if ( computer.coba.check( pt ) )
	    {
	      double r;
	      typename std::map<Vertex, double>::const_iterator mit =
		map_vtx2radius.find( wvtx.cell );
	      bool found = ( mit != map_vtx2radius.end() );
	      if ( found )
		{ // found in map_vtx2radius
		  r = mit->second;
		  expander2.init( *myDGraph, wvtx.cell, myDist );
		  expander2.expandNoGreaterThan( r, RingInserter( new_ring ) );
		}
	      else 
		{
		  // not found in map_vtx2radius
		  // std::cerr << "[NuThickDisk] ERROR !" << std::endl;
		  disk.init( *myDGraph, wvtx.cell, myThickness );
		  disk.computeDisk( -1.0 );
		  r = disk.radius();
		  map_vtx2radius[ wvtx.cell ] = r;
		}
	      if ( r <= this->limitRadius() )
		//if ( disk.radius() < this->radius() )
		{
// 		  const Set disk_vertices = disk.diskVertices();
                  typename Expander::MarkedSet disk_vertices = 
		    found ? expander2.visitedVertices()
		    : disk.diskVertices();
		  is_in_max_plane = this->areInBand( disk_vertices.begin(),
						     disk_vertices.end() );
		  if ( is_in_max_plane ) 
		    {
		      core += wvtx.cell;
		      for ( typename Expander::MarkedSet::const_iterator
			      it = disk_vertices.begin(),
			      it_end =  disk_vertices.end(); it != it_end; ++it )
			maximal_plane += *it;
		      expander.expandNext();
		    }
		}
	    }
	} //       if ( all_cores.find( wvtx ) == all_cores.end() )
      if ( ! is_in_max_plane ) 
	expander.ignoreNext();
    }
  //  std::cerr << "  after=" << vertices.size() << std::endl;
  new_ring.clear();
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
void
ImaGene::NuThickDisk<TDigitalGraph>::
computeMaximalPlane( Set & maximal_plane )
{
  NuThickDisk<DigitalGraph> disk;
  Point3i pt;
  Computer & computer = *( myComputer[ majorAxis() ] );
  Expander & expander = computer.expander; 
  //maximal_plane = expander.exploredVertices();
  maximal_plane.clear();
  typename Expander::MarkedSet::const_iterator itb = 
    expander.exploredVertices().begin();
  typename Expander::MarkedSet::const_iterator ite = 
    expander.exploredVertices().end();
  for ( ; itb != ite; ++itb ) maximal_plane += *itb;
  Set disk_vertices = myDGraph->emptySet();
  WeightedVertex wvtx;
  computer.coba.optimizeBand();
  while( ! expander.finished() )
    {
      //extract a surfel
      wvtx = expander.next();
      myDGraph->embed( wvtx.cell, pt.data() );
      // tests if it still corresponds to a digital plane
      bool is_in_max_plane = false;
      if ( computer.coba.check( pt ) )
	{
	  // Check if whole disk is inside band.  NB: JOL works very
	  // well with myVtx instead of wvtx.cell, but does not
	  // distinguish between tangency and within-slice.
	  disk.init( *myDGraph, wvtx.cell, myThickness );
	  disk.computeDisk( -1.0 );
	  if ( disk.radius() < this->limitRadius() )
	    //if ( disk.radius() < this->radius() )
	    {
	      disk.getDiskVertices( disk_vertices );
	      is_in_max_plane = this->areInBand( disk_vertices.begin(),
						 disk_vertices.end() );
	    }
	}
      if ( is_in_max_plane ) 
	{
	  maximal_plane += wvtx.cell;
	  expander.expandNext();
	}
      else
	{
	  maximal_plane -= wvtx.cell;
	  expander.ignoreNext();
	}
    }
  //  std::cerr << "  after=" << vertices.size() << std::endl;
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
void
ImaGene::NuThickDisk<TDigitalGraph>::
computeExactMaximalPlane( Set & maximal_plane )
{
  NuThickDisk<DigitalGraph> disk;
  Point3i pt;
  Computer & computer = *( myComputer[ majorAxis() ] );
  Expander expander = computer.expander; 
  //maximal_plane = expander.exploredVertices();
  maximal_plane.clear();
  typename Expander::MarkedSet::const_iterator itb = 
    expander.exploredVertices().begin();
  typename Expander::MarkedSet::const_iterator ite = 
    expander.exploredVertices().end();
  for ( ; itb != ite; ++itb ) maximal_plane += *itb;
  WeightedVertex wvtx;
  COBAAlgorithm::State saveRingState;
  computer.coba.getState( saveRingState );
  Set disk_vertices = myDGraph->emptySet();
  while( ! expander.finished() )
    {
      //extract a surfel
      wvtx = expander.next();
      myDGraph->embed( wvtx.cell, pt.data() );
      // tests if it still corresponds to a digital plane
      bool is_in_max_plane = false;
      if ( computer.coba.check( pt ) )
	{
	  // Check if whole disk is inside band.  NB: JOL works very
	  // well with myVtx instead of wvtx.cell, but does not
	  // distinguish between tangency and within-slice.
	  disk.init( *myDGraph, wvtx.cell, myThickness );
	  disk.computeDisk( -1.0 );
	  if ( disk.radius() < this->limitRadius() )
	    {
	      // Set disk_vertices = disk.diskVertices();
	      disk.getDiskVertices( disk_vertices );
	      is_in_max_plane = true;
	      for ( typename Set::iterator it = disk_vertices.begin(),
		      it_end = disk_vertices.end();
		    it != it_end; ++it )
		{
		  myDGraph->embed( *it, pt.data() );
		  if ( ! computer.coba.add( pt, true ) )
		    {
		      is_in_max_plane = false;
		      break;
		    }
		}
	        computer.coba.setState( saveRingState );
	    }
	}
      if ( is_in_max_plane ) 
	{
	  maximal_plane += wvtx.cell;
	  expander.expandNext();
	}
      else
	{
	  maximal_plane -= wvtx.cell;
	  expander.ignoreNext();
	}
    }
  //  std::cerr << "  after=" << vertices.size() << std::endl;
}


//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
void
ImaGene::NuThickDisk<TDigitalGraph>::getDiskVertices
( Set & disk_vertices ) const
{
  typedef typename Expander::MarkedSet MarkedSet;
  typedef typename MarkedSet::const_iterator MarkedSetConstIterator;
  MarkedSet s = myComputer[ majorAxis() ]->expander.visitedVertices();
  disk_vertices.clear();
  for ( MarkedSetConstIterator it = s.begin(), ite = s.end();
	it != ite; ++it )
    disk_vertices += *it;
  // return myComputer[ majorAxis() ]->expander.visitedVertices();
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
typename ImaGene::NuThickDisk<TDigitalGraph>::MarkedSet
ImaGene::NuThickDisk<TDigitalGraph>::diskVertices() const
{
  return myComputer[ majorAxis() ]->expander.visitedVertices();
}

//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
const typename ImaGene::NuThickDisk<TDigitalGraph>::Vertex & 
ImaGene::NuThickDisk<TDigitalGraph>::center() const
{
  return myVtx;
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
const typename ImaGene::NuThickDisk<TDigitalGraph>::Point3i & 
ImaGene::NuThickDisk<TDigitalGraph>::centerEmbedding() const
{
  return myPt;
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
unsigned int
ImaGene::NuThickDisk<TDigitalGraph>::majorAxis() const
{
  return myMajorAxis;
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
unsigned int
ImaGene::NuThickDisk<TDigitalGraph>::size() const
{
  return myComputer[ myMajorAxis ]->coba.size();
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
double
ImaGene::NuThickDisk<TDigitalGraph>::radius() const
{
  return myComputer[ myMajorAxis ]->radius;
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
double
ImaGene::NuThickDisk<TDigitalGraph>::limitRadius() const
{
  return myComputer[ myMajorAxis ]->limit_radius;
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
double
ImaGene::NuThickDisk<TDigitalGraph>::thickness() const
{
  return myThickness;
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
template <typename Vector3d>
inline
void
ImaGene::NuThickDisk<TDigitalGraph>::getNormal( Vector3d & n ) const
{
  myComputer[ myMajorAxis ]->coba.getNormal( n );
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
template <typename Vector3d>
inline
void
ImaGene::NuThickDisk<TDigitalGraph>::getUnitNormal( Vector3d & n ) const
{
  myComputer[ myMajorAxis ]->coba.getUnitNormal( n );
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
template <typename Vector3d>
inline
void
ImaGene::NuThickDisk<TDigitalGraph>::getUpperPoint
( Vector3d & upper_pt ) const
{
  myComputer[ myMajorAxis ]->coba.getUpper( upper_pt );
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
template <typename Vector3d>
inline
void
ImaGene::NuThickDisk<TDigitalGraph>::getLowerPoint
( Vector3d & lower_pt ) const
{
  myComputer[ myMajorAxis ]->coba.getLower( lower_pt );
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
void
ImaGene::NuThickDisk<TDigitalGraph>::
getBounds( double & min, double & max ) const
{
  myComputer[ myMajorAxis ]->coba.getBounds( min, max );
}
//-----------------------------------------------------------------------------
// Interface - public :
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
void
ImaGene::NuThickDisk<TDigitalGraph>::selfDisplay
( std::ostream& that_stream ) const
{
  that_stream << "[NuThickDisk"
	      << " mA=" << myMajorAxis
	      << " r=" << radius()
	      << "]";
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
bool
ImaGene::NuThickDisk<TDigitalGraph>::OK() const
{
  return true;
}

///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions and external operators                 //

/**
 * Overloads 'operator<<' for displaying objects of class 'NuThickDisk'.
 * @param that_stream the output stream where the object is written.
 * @param that_object_to_display the object of class 'NuThickDisk' to write.
 * @return the output stream after the writing.
 */
template <typename TDigitalGraph>
inline
std::ostream&
ImaGene::operator<<( std::ostream & that_stream, 
		     const NuThickDisk<TDigitalGraph> & that_object_to_display )
{
  that_object_to_display.selfDisplay( that_stream );
  return that_stream;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


