//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// File name : TangentialCoverHierarchy.ih
//
// Creation : 2011/01/14
//
// Version : 2011/01/14
//
// Author : JOL
//
// Summary : Implementation of inline methods defined in TangentialCoverHierarchy.h 
//
// History :
//	2011/01/14 : ?Name? : ?What?
//
// Rcs Id : "@(#)class TangentialCoverHierarchy declaration."
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
#include <iostream>
#include <list>
#include <map>
#include "ImaGene/mathutils/Statistic.h"
#include "ImaGene/timetools/Clock.h"
//////////////////////////////////////////////////////////////////////////////

#if defined(NO_DEBUG)
#define ASSERT_TangentialCoverHierarchy(x)
#define DEBUGCMD_TangentialCoverHierarchy(x)
#else //defined(NO_DEBUG)
#define ASSERT_TangentialCoverHierarchy(x) if(!(x)) \
    { std::cerr << "Assertion failed : (" << #x << ')' << std::endl \
    << "In file : " << __FILE__ << " at line #" << __LINE__ << std::endl \
    << "Compiled the " << __DATE__ << " at " << __TIME__ << std::endl; abort();}
#define DEBUGCMD_TangentialCoverHierarchy(x) x
#endif // else defined(NO_DEBUG)

///////////////////////////////////////////////////////////////////////////////
// Implementation of inline methods                                          //
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
ImaGene::TangentialCoverHierarchy<TDigitalGraph>::~TangentialCoverHierarchy()
{
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
ImaGene::TangentialCoverHierarchy<TDigitalGraph>::TangentialCoverHierarchy()
  : myDGraph( 0 )
{}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
const ImaGene::TangentialCover<TDigitalGraph> & 
ImaGene::TangentialCoverHierarchy<TDigitalGraph>::
tangentialCover( int scale_idx ) const
{
  return myTangentialCovers[ scale_idx ]; 
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
ImaGene::TangentialCover<TDigitalGraph> & 
ImaGene::TangentialCoverHierarchy<TDigitalGraph>::
tangentialCover( int scale_idx )
{
  return myTangentialCovers[ scale_idx ]; 
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
void 
ImaGene::TangentialCoverHierarchy<TDigitalGraph>::init
( const DigitalGraph & dgraph, const std::vector<double> & scales )
{
  clear();
  myDGraph = &dgraph;
  myScales = scales;
  myScales.insert( myScales.begin(), -100000.0 );
  myActiveVtx.resize( myScales.size() + 1 );
  myActiveVtx[ 0 ] = new Set( myDGraph->wholeSet() );
  for ( unsigned int i = 1; i < myActiveVtx.size(); ++i )
    myActiveVtx[ i ] = new Set( myDGraph->emptySet() );
  myTangentialCovers.clear();
  myTangentialCovers.resize( myScales.size() );
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
void 
ImaGene::TangentialCoverHierarchy<TDigitalGraph>::clear()
{
  for ( unsigned int i = 0; i < myActiveVtx.size(); ++i )
    if ( myActiveVtx[ i ] != 0 ) delete myActiveVtx[ i ];
  myActiveVtx.clear();
  myScales.clear();
  myTangentialCovers.clear();
  myDGraph = 0;
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
void 
ImaGene::TangentialCoverHierarchy<TDigitalGraph>::computeActiveVertices
( PriorityQueue & fp, std::list<WeightedVertex> & active_vtx ) const
{
  if ( myDGraph == 0 ) return;
  const DigitalGraph & dsg = *myDGraph;
  NuThickDisk<DigitalGraph> disk;
  // Set* extension = new Set( myDGraph->emptySet() );
  active_vtx.clear();
  std::list<WeightedVertex> reversed_queue;
  while( ! fp.empty() )
    {
      WeightedVertex wv = fp.top();
      fp.pop();
      reversed_queue.push_front( wv );
    }
  typename std::list<WeightedVertex>::iterator itOnList;    //for each disk
  while( ! reversed_queue.empty() )
    {
      WeightedVertex wv = reversed_queue.front();
      reversed_queue.pop_front();
      // check if the extracted disk is included in a larger one
      for ( itOnList = active_vtx.begin(); 
	    itOnList != active_vtx.end(); 
	    ++itOnList )
	{
	  //the extracted disk is not maximal, 
	  // removes it from the main map correspondingSurf
	  if ( ( wv.weight < itOnList->weight2 )
	       && isBallIncluded( wv, *itOnList ) ) 
	    break;
	}
      //the extracted disk is maximal
      if ( itOnList == active_vtx.end() ) 
	{
	  active_vtx.push_back( wv );
	  // (*current_set) += wv.cell;
	}
    } //while(!fp.empty())
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
void 
ImaGene::TangentialCoverHierarchy<TDigitalGraph>::computeActiveVertices2
( PriorityQueue & fp, 
  std::list<WeightedVertex> & active_vtx,
  Methods & methods,
  double width ) const
{
  if ( myDGraph == 0 ) return;
  const DigitalGraph & dsg = *myDGraph;
  NuThickDisk<DigitalGraph> disk;
  Set* extension = new Set( myDGraph->emptySet() );
  active_vtx.clear();
  while( ! fp.empty() )
    {
      active_vtx.push_front( fp.top() );
      fp.pop();
    }
  EuclideanDigitalDistance edd( myDGraph->dim() );
  typename ComputedDisk::Expander expander;
  std::deque<Vertex> disk_vtx;
  typedef typename std::list<WeightedVertex>::iterator ListIterator;
  ListIterator it1;    //for each disk
  ListIterator it2;    //for each disk
  for ( it1 = active_vtx.begin(); 
	it1 != active_vtx.end(); 
	++it1 )
    {
      WeightedVertex wv = *it1;
      Vertex vtx1 = wv.cell;
      disk.init( dsg, vtx1, width );
      disk.computeDisk( methods.preferredAxis( vtx1 ), wv.weight );
      disk.computeExtension( *extension );
      it2 = it1; ++it2;
      while( it2 != active_vtx.end() )
	{
	  Vertex vtx2 = it2->cell;
	  if ( ( it2->weight < wv.weight ) && isBallIncluded( *it2, wv ) ) 
	    it2 = active_vtx.erase( it2 );
	  else if ( (*extension)[ vtx2 ] )
	    {
	      expander.init( dsg, vtx2, edd );
	      bool out = false;
	      while ( ! expander.finished() )
		{
		  WeightedCell<Vertex> wv3;
		  expander.expandNext( wv3 );
		  if ( wv3.weight > it2->weight ) break;
		  else if ( ! (*extension)[ wv3.cell ] )
		    {
		      out = true;
		      break;
		    }
		}
	      if ( out )
		++it2;
	      else
		it2 = active_vtx.erase( it2 );
	    }
	  else ++it2;
	}
    } //while(!fp.empty())
  delete extension;
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
void 
ImaGene::TangentialCoverHierarchy<TDigitalGraph>::computeActiveVertices3
( PriorityQueue & fp, 
  std::list<WeightedVertex> & active_vtx,
  Methods & methods,
  double width ) const
{
  if ( myDGraph == 0 ) return;
  const DigitalGraph & dsg = *myDGraph;
  NuThickDisk<DigitalGraph> disk;
  Set* extension = new Set( myDGraph->emptySet() );
  active_vtx.clear();
  while( ! fp.empty() )
    {
      // reverse order so that greater disks are before smaller disks.
      active_vtx.push_front( fp.top() );
      fp.pop();
    }
  EuclideanDigitalDistance edd( myDGraph->dim() );
  typename ComputedDisk::Expander expander;
  std::deque<Vertex> disk_vtx;
  typedef typename std::list<WeightedVertex>::iterator ListIterator;
  ListIterator it1;    //for each disk
  ListIterator it2;    //for each disk
  for ( it1 = active_vtx.begin(); 
	it1 != active_vtx.end(); 
	++it1 )
    {
      WeightedVertex wv = *it1;
      Vertex vtx1 = wv.cell;
      disk.init( dsg, vtx1, width );
      disk.computeDisk( wv.weight );
      disk.computeExtension( *extension );
      it2 = it1; ++it2;
      while( it2 != active_vtx.end() )
	{
	  Vertex vtx2 = it2->cell;
	  if ( it2->weight >= wv.weight )
	    ++it2;
	  else if ( isBallIncluded( *it2, wv ) ) // speed up
	    it2 = active_vtx.erase( it2 );
	  else if ( isIncluded( *it2, wv ) ) // v1 \in ball_\nu( v2 )
	    {
	      // disk_\nu( v1 ) < ext_\nu( v2 )
	      expander.init( dsg, vtx2, edd );
	      bool out = false;
	      while ( ! expander.finished() )
		{
		  WeightedCell<Vertex> wv3;
		  expander.expandNext( wv3 );
		  if ( wv3.weight > it2->weight ) break;
		  else if ( ! (*extension)[ wv3.cell ] )
		    {
		      out = true;
		      break;
		    }
		}
	      if ( out )
		++it2;
	      else
		it2 = active_vtx.erase( it2 );
	    }
	  else ++it2;
	}
    } //while(!fp.empty())
  delete extension;
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
void 
ImaGene::TangentialCoverHierarchy<TDigitalGraph>::computeActiveVertices
( PriorityQueue & fp, 
  WeightedVertexList & active_vtx,
  MapVertexToVertexSet & map_inactive2actives ) const
{
  if ( myDGraph == 0 ) return;
  const DigitalGraph & dsg = *myDGraph;
  NuThickDisk<DigitalGraph> disk;
  active_vtx.clear();
  std::list<WeightedVertex> reversed_queue;
  while( ! fp.empty() )
    {
      WeightedVertex wv = fp.top();
      fp.pop();
      reversed_queue.push_front( wv );
    }
  typename WeightedVertexList::iterator itOnList;    //for each disk
  while( ! reversed_queue.empty() )
    {
      WeightedVertex wv = reversed_queue.front();
      //std::cerr << "(r=" << wv.weight;
      reversed_queue.pop_front();
      bool is_active = true;
      // check if the extracted disk is included in a larger one
      for ( itOnList = active_vtx.begin(); 
	    itOnList != active_vtx.end(); 
	    ++itOnList )
	{
	  //the extracted disk is not maximal, 
	  // removes it from the main map correspondingSurf
	  if ( ( wv.weight < itOnList->weight2 )
	       && isBallIncluded( wv, *itOnList ) )
	    {
	      map_inactive2actives[ wv.cell ].insert( itOnList->cell );
	      // break;
	      is_active = false;
	    }
	}
      //the extracted disk is maximal
      if ( is_active ) // ex (itOnList == active_vtx.end() ) 
	{
	  active_vtx.push_back( wv );
	  //std::cerr << "*";
	}
      //std::cerr << ")";
    } //while(!fp.empty())
  //std::cerr << std::endl;
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
typename ImaGene::TangentialCoverHierarchy<TDigitalGraph>::VertexSet
ImaGene::TangentialCoverHierarchy<TDigitalGraph>::reduceActives
( Vertex vtx, MapVertexToVertexSet & i2a )
{
  typename MapVertexToVertexSet::iterator it_i2a = i2a.find( vtx );
  VertexSet new_active_vtxs;
  if ( it_i2a != i2a.end() ) // found
    {
      VertexSet & active_vtxs = it_i2a->second;
      for ( typename VertexSet::const_iterator 
	      its = active_vtxs.begin(), 
	      its_end = active_vtxs.begin();
	    its != its_end; ++its )
	{
	  VertexSet other = reduceActives( *its );
	  if ( other.size() != 0 )
	    new_active_vtxs.insert( other.begin(), other.end() );
	  else
	    new_active_vtxs.insert( *its );
	}
      active_vtxs = new_active_vtxs;
    }
  return new_active_vtxs;
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
void 
ImaGene::TangentialCoverHierarchy<TDigitalGraph>::completeActiveVertices
( MapVertexToVertexSet & i2a,
  const MapVertexToVertexSet & former_i2a ) const
{
  if ( myDGraph == 0 ) return;
  const DigitalGraph & dsg = *myDGraph;
  Set vertices = dsg.wholeSet();
  for ( SetConstIterator it = vertices.begin(), it_end = vertices.end();
	it != it_end; ++it )
    {
      Vertex vtx = *it;
      typename MapVertexToVertexSet::iterator it_i2a = i2a.find( vtx );
      if ( it_i2a == i2a.end() ) // not found
	{
	  typename MapVertexToVertexSet::const_iterator it_former_i2a =
	    former_i2a.find( vtx );
	  if ( it_former_i2a != former_i2a.end() ) // found
	    { // update it.
	      const VertexSet & former_active_vtxs = it_former_i2a->second;
	      for ( typename VertexSet::const_iterator 
		      its = former_active_vtxs.begin(), 
		      its_end = former_active_vtxs.end();
		    its != its_end; ++its )
		{
		  Vertex active_vtx = *its;
		  it_i2a = i2a.find( active_vtx );
		  if ( it_i2a == i2a.end() ) // not found
		    // vertex is still an active vertex.
		    i2a[ vtx ].insert( active_vtx );
		  else
		    i2a[ vtx ].insert( it_i2a->second.begin(),
				       it_i2a->second.end() );
		} // end loop on all active vertices.
	    }
	}
    } 
}

//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
void 
ImaGene::TangentialCoverHierarchy<TDigitalGraph>::
computeTangentialCovers( Methods & methods, bool not_in_core )
{
  if ( myDGraph == 0 ) return;
  const DigitalGraph & dsg = *myDGraph;
  NuThickDisk<DigitalGraph> disk;
  std::vector<double> normalVector(3); 
  PriorityQueue fp;
  
  for ( int scale_idx = 1; scale_idx < myScales.size();  ++scale_idx )
    {
      Statistic<float> Xradius;
      std::map<Vertex,double> m;  //associative table vertex <-> max radius
      double width = myScales[ scale_idx ];
      std::cerr << "---- Scale " << ( scale_idx - 1 )
		<< " is " << width << " ----" << std::endl;
      Clock::startClock();
      const Set* previous_set = myActiveVtx[ scale_idx - 1 ];
      Set* current_set = myActiveVtx[ scale_idx ];
      for ( SetConstIterator p = previous_set->begin();
	    p != previous_set->end(); ++p )
	{
	  Vertex vtx = *p;
	  disk.init( dsg, vtx, width );
	  disk.computeDisk( -1.0 );
	  disk.getNormal( normalVector );
	  // methods.adjustOrientation( vtx, normalVector );
	  Xradius.addValue( disk.radius() );
	  fp.push( WeightedVertex( vtx, disk.radius(), disk.limitRadius() ) );
	  m.insert(std::pair<Vertex,double>(vtx,disk.radius()));
	}
      long t1 = Clock::stopClock();
      std::cerr << "   nb_computed = " << Xradius.samples() << std::endl
		<< "   Xradius = " << Xradius.mean() 
		<< " +/- " << sqrt( Xradius.variance() ) << std::endl
		<< "   in " << t1 << " ms." << std::endl;
      // Compute tangential cover
      std::cerr << "---- Tangential cover[begin] " << ( scale_idx - 1 ) << std::endl;
      Clock::startClock();
      TangentialCover<DigitalGraph> & tcover = myTangentialCovers[scale_idx-1];
      tcover.myDGraph = myDGraph;
      tcover.myScale = width;
      computeActiveVertices( fp, 
			     tcover.myActiveVertices, 
			     tcover.myVtx2Actives );
      if ( scale_idx > 1 )
	completeActiveVertices( tcover.myVtx2Actives,
				myTangentialCovers[scale_idx-2].myVtx2Actives );
//        tcover.computeMaximalPlanes( methods, not_in_core );
     tcover.computeMaximalPlanes( methods, not_in_core, m );
      long t2 = Clock::stopClock();
      std::cerr << "---- Tangential cover[end] in " << t2 << " ms." << std::endl;
      
      int coords[ 3 ];
      WeightedVertexList f = tcover.myActiveVertices; //need a simple list
      while ( ! f.empty() )
	{
	  (*current_set) += f.front().cell;
	  dsg.embed( f.front().cell, coords );
	  f.pop_front();
	}
      
      std::cerr << "Found " << current_set->size() << " active vertices."
		<< std::endl;
 
    }
}


//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
void 
ImaGene::TangentialCoverHierarchy<TDigitalGraph>::compute
( Methods & methods,
  bool ball_inclusion )
{
  if ( myDGraph == 0 ) return;
  const DigitalGraph & dsg = *myDGraph;
  NuThickDisk<DigitalGraph> disk;
  std::vector<double> normalVector(3); 
  PriorityQueue fp;
  Set* extension = new Set( myDGraph->emptySet() );
  for ( int scale_idx = 1; scale_idx < myScales.size();  ++scale_idx )
    {
      Statistic<float> Xradius;
      double width = myScales[ scale_idx ];
      std::cerr << "---- Scale " << ( scale_idx - 1 )
		<< " is " << width << " ----" << std::endl;
      Clock::startClock();
      const Set* previous_set = myActiveVtx[ scale_idx - 1 ];
      Set* current_set = myActiveVtx[ scale_idx ];
      for ( SetConstIterator p = previous_set->begin();
	    p != previous_set->end(); ++p )
	{
	  Vertex vtx = *p;
	  // std::cerr << vtx << std::endl;
	  disk.init( dsg, vtx, width );
	  // progressive computations work !
	  disk.computeDisk( -1.0 );
	  disk.getNormal( normalVector );
	  std::cout<<"*************************************************"<<std::endl;
	  std::cout<<"normal vector of the disk : ("<< normalVector[ 0 ] 
 	       << "," << normalVector[ 1 ] 
 	       << "," << normalVector[ 2 ] << ")" << std::endl;
          std::cout<<"try to refine..."<<std::endl;
	  //ajout
	  disk.refineNormal();
	  // for ( double maxd = 1.0; maxd < 1000.0; maxd += 0.5 )
	  //   {
	  //     if ( disk.computeDisk( methods.preferredAxis( vtx ), maxd ) )
	  // 	break;
	  //   }
	  disk.getNormal( normalVector );
	  std::cout<<"refined normal vector : ("<< normalVector[ 0 ] 
 	       << "," << normalVector[ 1 ] 
 	       << "," << normalVector[ 2 ] << ")" << std::endl;
	  std::cout<<"*************************************************"<<std::endl;
	  methods.adjustOrientation( vtx, normalVector );
	  Xradius.addValue( disk.radius() );
	  fp.push( WeightedVertex( vtx, disk.radius(), disk.limitRadius() ) );

	  // disk.computeExtension( *extension );
	  // Xextsize.addValue( extension->size() );
// 	  cerr << "Cell=" << bel << " r=" << disk.radius() 
// 	       << " #=" << disk.size() 
// 	       << " axis=" << disk.majorAxis() 
// 	       << " N=(" << normalVector[ 0 ] 
// 	       << "," << normalVector[ 1 ] 
// 	       << "," << normalVector[ 2 ] << ")" << endl;
	}
      long t1 = Clock::stopClock();
      std::cerr << "   nb_computed = " << Xradius.samples() << std::endl
		<< "   Xradius = " << Xradius.mean() 
		<< " +/- " << sqrt( Xradius.variance() ) << std::endl
		// << "   Xextsize = " << Xextsize.mean() 
		// << " +/- " << sqrt( Xextsize.variance() ) << std::endl
		<< "   in " << t1 << " ms." << std::endl;

      std::list<WeightedVertex> f; //need a simple list
      if ( ball_inclusion )
	computeActiveVertices( fp, f );
      else
	computeActiveVertices3( fp, f, methods, width );
      int coords[ 3 ];
      while ( ! f.empty() )
	{
	  (*current_set) += f.front().cell;
	  dsg.embed( f.front().cell, coords );
	  f.pop_front();
// 	  std::cerr << "(" << coords[ 0 ] << "," << coords[ 1 ] << "," << coords[ 2 ] << ") ";
	}
      
      std::cerr << "Found " << current_set->size() << " active vertices."
		<< std::endl;
 
    }
  delete extension;
}
//-----------------------------------------------------------------------------
/** code similar to compute
    but store the successive normal vectors in maps to estimate the normal vector at each
    surfel**/
/** bug**/
template <typename TDigitalGraph>
inline
void 
ImaGene::TangentialCoverHierarchy<TDigitalGraph>::computeNormals
( Methods & methods, std::map< int,std::map< double,Statistic<float> > > & greedyNxMap,
                                                           std::map< int,std::map< double,Statistic<float> > > & greedyNyMap,
							   std::map< int,std::map< double,Statistic<float> > > & greedyNzMap)
{
  if ( myDGraph == 0 ) return;
  const DigitalGraph & dsg = *myDGraph;
  NuThickDisk<DigitalGraph> disk;
  std::vector<double> normalVector(3); 
  PriorityQueue fp;
  std::map< double,Statistic<float> > littleMap;
  Statistic<float> fstat;    
	    
  for ( int scale_idx = 1; scale_idx < myScales.size();  ++scale_idx )
    {
      double width = myScales[ scale_idx ];
      std::cerr << "---- Scale " << ( scale_idx - 1 )
		<< " is " << width << " ----" << std::endl;
      Clock::startClock();
      const Set* previous_set = myActiveVtx[ scale_idx - 1 ];
      Set* current_set = myActiveVtx[ scale_idx ];
      for ( SetConstIterator p = previous_set->begin();
	    p != previous_set->end(); ++p )
	{
	  Vertex vtx = *p;
	  disk.init( dsg, vtx, width );
	  disk.computeDisk( methods.preferredAxis( vtx ), -1 );
	  disk.getNormal( normalVector );
	  methods.adjustOrientation( vtx, normalVector );
	  fp.push( WeightedVertex( vtx, disk.radius(), disk.limitRadius() ) );
	}
      long t1 = Clock::stopClock();

      std::list<WeightedVertex> f; //need a simple list
      typename std::list<WeightedVertex>::iterator itOnList;    //for each disk
      while( ! fp.empty() )
	{
	  WeightedVertex wv = fp.top();
	  fp.pop();
// 	  check if the extracted disk is included in a larger one
	  for ( itOnList = f.begin(); itOnList != f.end(); ++itOnList )
	    {
// 	      the extracted disk is not maximal, 
// 	      removes it from the main map correspondingSurf
	      if ( isBallIncluded( wv, *itOnList ) ) 
		break;
	    }
// 	  the extracted disk is maximal
	  if ( itOnList == f.end() ) 
	    {
	      f.push_back( wv );
	      (*current_set) += wv.cell;
	    }
	} //while(!fp.empty())
      
      std::cerr << "Found " << current_set->nbElements() << " active vertices."
		<< std::endl;
	
//       for each active vertex, compute its extension and
//       associate its normal vector to each covered vertex
      for ( SetConstIterator p = current_set->begin();
	    p != current_set->end(); ++p )
      {
          Vertex vtx = *p;
          disk.init( dsg, vtx, width );
	  disk.computeDisk( methods.preferredAxis( vtx ), -1 );
	  disk.getNormal( normalVector );
	  methods.adjustOrientation( vtx, normalVector );
	  Set * exp = new Set( myDGraph->emptySet() );
	  disk.computeExtension(*exp);
	  for ( SetConstIterator q = exp->begin();
	    q != exp->end(); ++q )
	  {
// 	    associer le vecteur normal au sommet
	    Vertex v = *q;

	    greedyNxMap.insert(std::make_pair(v,littleMap));
	    greedyNxMap[v].insert(std::make_pair(width,fstat));
	    greedyNxMap[v][width].addValue(normalVector[0]);
	  
	    greedyNyMap.insert(std::make_pair(v,littleMap));
	    greedyNyMap[v].insert(std::make_pair(width,fstat));
	    greedyNyMap[v][width].addValue(normalVector[1]);
	  
	    greedyNzMap.insert(std::make_pair(v,littleMap));
	    greedyNzMap[v].insert(std::make_pair(width,fstat));
	    greedyNzMap[v][width].addValue(normalVector[2]);
	  } // for ( SetConstIterator q = expVertices->begin(); q != expVertices->end(); ++q )
      } //for ( SetConstIterator p = current_set->begin(); p != current_set->end(); ++p )
    }
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
void 
ImaGene::TangentialCoverHierarchy<TDigitalGraph>::compute2
( Methods & methods )
{
  if ( myDGraph == 0 ) return;
  const DigitalGraph & dsg = *myDGraph;
  Neighborhood neighborhood;
  NuThickDisk<DigitalGraph> disk;
  std::vector<double> normalVector(3); 
  PriorityQueue fp;
  Set* extension = new Set( myDGraph->emptySet() );
  Point3i pt2;
  for ( int scale_idx = 1; scale_idx < myScales.size();  ++scale_idx )
    {
      Statistic<float> Xradius;
      Statistic<float> Xextsize;
      double width = myScales[ scale_idx ];
      std::cerr << "---- Scale " << ( scale_idx - 1 )
		<< " is " << width << " ----" << std::endl;
      Clock::startClock();
      const Set* previous_set = myActiveVtx[ scale_idx - 1 ];
      Set* current_set = myActiveVtx[ scale_idx ];
      MapVertexToDisk memory;
      for ( SetConstIterator p = previous_set->begin();
	    p != previous_set->end(); ++p )
	{
	  Vertex vtx = *p;
	  // std::cerr << "+- Vertex " << vtx;
	  MapVertexToDiskIterator it = memory.find( *p );
	  if ( it != memory.end() )
	    // found a computed disk
	    disk.init( vtx, it->second );
	  else // from scratch
	    disk.init( dsg, vtx, width );
	  // std::cerr << " disk.r " << disk.radius();
	  std::vector< NuThickDisk< DigitalGraph> > intermediate_disks;
	  std::vector< double > radii;
	  for ( double d = std::max( disk.radius(), 2.0 ); 
		d < myDGraph->diameter(); 
		d += 0.5 )
	    {
	      bool done = disk.computeDisk( methods.preferredAxis( vtx ),
					    d );
	      if ( done ) break;
	      intermediate_disks.push_back( disk );
	      radii.push_back( d );
	    }
	  // Check stats
	  // std::cerr << " -> " << disk.radius() << std::endl;
	  disk.getNormal( normalVector );
	  methods.adjustOrientation( vtx, normalVector );
	  Xradius.addValue( disk.radius() );
	  fp.push( WeightedVertex( vtx, disk.radius(), disk.limitRadius() ) );
	  disk.computeExtension( *extension );
	  Xextsize.addValue( extension->size() );
	  // Contaminate neighbors
	  myDGraph->setProperNeighborhood( vtx, neighborhood );
	  for ( NeighborhoodConstIterator itn = neighborhood.begin();
		itn != neighborhood.end();
		++itn )
	    {
	      Vertex vtx2 = *itn;
	      myDGraph->embed( vtx2, pt2.data() );
	      double d = NuThickDisk<DigitalGraph>::
		distance( disk.centerEmbedding(), pt2 );
	      double radius = disk.radius() - 2*d;
	      int i = intermediate_disks.size() - 1;
	      while ( ( i >= 0 ) && ( radii[ i ] > radius ) ) --i;
	      if ( ( i >= 0 ) && ( radii[ i ] >= 2.0 ) )
		{
		  it = memory.find( vtx2 );
		  if ( ( it == memory.end() ) 
		       || ( (it->second).radius() < radii[ i ] ) )
		    memory[ vtx2 ] = intermediate_disks[ i ];
		}
	    }
// 	  cerr << "Cell=" << bel << " r=" << disk.radius() 
// 	       << " #=" << disk.size() 
// 	       << " axis=" << disk.majorAxis() 
// 	       << " N=(" << normalVector[ 0 ] 
// 	       << "," << normalVector[ 1 ] 
// 	       << "," << normalVector[ 2 ] << ")" << endl;
	}
      long t1 = Clock::stopClock();
      std::cerr << "   nb_computed = " << Xradius.samples() << std::endl
		<< "   Xradius = " << Xradius.mean() 
		<< " +/- " << sqrt( Xradius.variance() ) << std::endl
		<< "   Xextsize = " << Xextsize.mean() 
		<< " +/- " << sqrt( Xextsize.variance() ) << std::endl
		<< "   in " << t1 << " ms." << std::endl;

      std::list<WeightedVertex> f; //need a simple list
      typename std::list<WeightedVertex>::iterator itOnList;    //for each disk
      while( ! fp.empty() )
	{
	  WeightedVertex wv = fp.top();
	  fp.pop();
	  // check if the extracted disk is included in a larger one
	  for ( itOnList = f.begin(); itOnList != f.end(); ++itOnList )
	    {
	      //the extracted disk is not maximal, 
	      // removes it from the main map correspondingSurf
	      if ( isBallIncluded( wv, *itOnList ) ) 
		break;
	    }
	  //the extracted disk is maximal
	  if ( itOnList == f.end() ) 
	    {
	      f.push_back( wv );
	      (*current_set) += wv.cell;
	    }
	} //while(!fp.empty())
      
      std::cerr << "Found " << current_set->size() << " active vertices."
		<< std::endl;
 
    }
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
typename ImaGene::TangentialCoverHierarchy<TDigitalGraph>::Set
ImaGene::TangentialCoverHierarchy<TDigitalGraph>::activeVertices
( int scale_idx ) const
{
  --scale_idx;
  if ( scale_idx < 0 ) return *( myActiveVtx[ 0 ] );
  else if ( scale_idx >= myScales.size() ) return myDGraph->emptySet();
  else return *( myActiveVtx[ scale_idx ] );
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
typename ImaGene::TangentialCoverHierarchy<TDigitalGraph>::Set
ImaGene::TangentialCoverHierarchy<TDigitalGraph>::activeVertices
( double scale ) const
{
  int scale_idx = 0;
  while ( ( scale_idx < myScales.size() )
	  && ( myScales[ scale_idx ] <= scale ) )
    ++scale_idx;
  return activeVertices( scale_idx );
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
bool
ImaGene::TangentialCoverHierarchy<TDigitalGraph>::isBallIncluded
( const WeightedVertex & c1, const WeightedVertex & c2 ) const
{
  double c1c2;
  Point3i p1;
  Point3i p2;
  myDGraph->embed( c1.cell, p1.data() );
  myDGraph->embed( c2.cell, p2.data() );
  c1c2 = NuThickDisk<DigitalGraph>::distance( p1, p2 );
  return ( (c1c2+c1.weight) <= c2.weight2 );
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
bool
ImaGene::TangentialCoverHierarchy<TDigitalGraph>::isIncluded
( const WeightedVertex & c1, const WeightedVertex & c2 ) const
{
  double c1c2;
  Point3i p1;
  Point3i p2;
  myDGraph->embed( c1.cell, p1.data() );
  myDGraph->embed( c2.cell, p2.data() );
  c1c2 = NuThickDisk<DigitalGraph>::distance( p1, p2 );
  return ( c1c2 < c2.weight2 );
}

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Noise services ---------------------------------
template <typename TDigitalGraph>
inline
void
ImaGene::TangentialCoverHierarchy<TDigitalGraph>::
getScaleProfile( ScaleProfile & sp,
		 Vertex vtx,
		 bool mp_area, bool saveForMedian ) const
{
  sp.clear();
  sp.init( ++myScales.begin(), myScales.end(), saveForMedian );
  for ( unsigned int i = 1; i < myScales.size(); ++i )
    {
      double rescale = 1.0 / ( myScales[ i ] * myScales[ i ] * myScales[ i ] );
      const TangentialCover<DigitalGraph> & tc = 
	this->tangentialCover( i-1 );
      std::vector<unsigned int> mp_indices;
      tc.getMaximalPlanesIndices( vtx, std::back_inserter( mp_indices ) );
      for ( std::vector<unsigned int>::const_iterator 
	      it = mp_indices.begin(), it_end = mp_indices.end();
	    it != it_end; ++it )
	{
	  unsigned int mp_index = *it;
	  double area = mp_area 
	    ? fabs( tc.maximalPlane( mp_index ).projectedArea )
	    : fabs( tc.maximalPlane( mp_index ).projectedDiskArea );
	  // std::cerr << "[" << i << "," 
	  // 	    << ( area / ( myScales[ i ] * myScales[ i ] ) ) 
	  // 	    << "] ";
	  sp.addValue( i-1, (float) ( area * rescale ) );
	}     
    }
  if(saveForMedian)
    sp.stopStatsSaving();
  
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
void 
ImaGene::TangentialCoverHierarchy<TDigitalGraph>::selfDisplay
( std::ostream & that_stream ) const
{
  that_stream << "[TangentialCoverHierarchy]";
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
bool 
ImaGene::TangentialCoverHierarchy<TDigitalGraph>::OK() const
{
  return true;
}
//-----------------------------------------------------------------------------



///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions and external operators                 //

/**
 * Overloads 'operator<<' for displaying objects of class
 * 'TangentialCoverHierarchy'.
 *
 * @param that_stream the output stream where the object is written.
 * @param that_object_to_display the object of class 'TangentialCoverHierarchy' to write.
 * @return the output stream after the writing.
 */
template <typename TDigitalGraph>
inline
std::ostream&
ImaGene::operator<<
( std::ostream & that_stream, 
  const TangentialCoverHierarchy<TDigitalGraph> & that_object_to_display )
{
  that_object_to_display.selfDisplay( that_stream );
  return that_stream;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


