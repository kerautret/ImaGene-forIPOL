//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// File name : TangentialCoverDecomposition.ih
//
// Creation : 2011/02/15
//
// Version : 2011/02/15
//
// Author : JOL
//
// Summary : Implementation of inline methods defined in TangentialCoverDecomposition.h 
//
// History :
//	2011/02/15 : ?Name? : ?What?
//
// Rcs Id : "@(#)class TangentialCoverDecomposition declaration."
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
#include <iostream>
#include <fstream>
//////////////////////////////////////////////////////////////////////////////

#if defined(NO_DEBUG)
#define ASSERT_TangentialCoverDecomposition(x)
#define DEBUGCMD_TangentialCoverDecomposition(x)
#else //defined(NO_DEBUG)
#define ASSERT_TangentialCoverDecomposition(x) if(!(x)) \
    { std::cerr << "Assertion failed : (" << #x << ')' << std::endl \
    << "In file : " << __FILE__ << " at line #" << __LINE__ << std::endl \
    << "Compiled the " << __DATE__ << " at " << __TIME__ << std::endl; abort();}
#define DEBUGCMD_TangentialCoverDecomposition(x) x
#endif // else defined(NO_DEBUG)

///////////////////////////////////////////////////////////////////////////////
// Implementation of inline methods                                          //

//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
ImaGene::TangentialCoverDecomposition<TDigitalGraph>::
~TangentialCoverDecomposition()
{
  if ( myActiveVertices != 0 ) delete myActiveVertices;
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
ImaGene::TangentialCoverDecomposition<TDigitalGraph>::
TangentialCoverDecomposition()
{
  myActiveVertices = 0;
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
void 
ImaGene::TangentialCoverDecomposition<TDigitalGraph>::
init( const DigitalGraph & dgraph, 
      double scale,
      const Set & active_vertices )
{
  clear();
  myDGraph = &dgraph;
  myScale = scale;
  if ( myActiveVertices != 0 ) delete myActiveVertices;
  myActiveVertices = new Set( active_vertices );
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
const TDigitalGraph*
ImaGene::TangentialCoverDecomposition<TDigitalGraph>::
digitalGraph() const
{
  return myDGraph;
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
double
ImaGene::TangentialCoverDecomposition<TDigitalGraph>::
scale() const
{
  return myScale;
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
void 
ImaGene::TangentialCoverDecomposition<TDigitalGraph>::
compute( Methods & methods,
	 DecompositionType type )
{
  switch ( type ) 
    {
    case Dominance:
      computeDominance( methods );
      break;
    case Segmentation:
      computeSegmentation( methods );
      break;
    case Accretion:
      computeAccretion( methods );
      break;
    case MaximalPlanes:
      computeMaximalPlanes( methods, false );
      break;
    case ExactMaximalPlanes:
      computeMaximalPlanes( methods, true );
      break;
    }
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
void 
ImaGene::TangentialCoverDecomposition<TDigitalGraph>::
computeDominance( Methods & methods )
{
  if ( myDGraph == 0 ) return;
  const DigitalGraph & dsg = *myDGraph;
  Neighborhood neighborhood;
  NuThickDisk<DigitalGraph> disk;
  NuThickDisk<DigitalGraph> disk2;
  std::vector<double> normalVector(3); 
  PriorityQueue fp;
  std::cerr << "-- Computing disks at scale=" << myScale << std::flush;
  Clock::startClock();
  for ( SetConstIterator p = myActiveVertices->begin(); p != myActiveVertices->end(); ++p )
    {
      Vertex vtx = *p;
      // std::cerr << vtx << std::endl;
      disk.init( dsg, vtx, myScale );
      disk.computeDisk( -1.0 );
      fp.push( WeightedVertex( vtx, disk.radius(), disk.limitRadius() ) );
    }
  long t1 = Clock::stopClock();
  std::cerr << " in " << t1 << " ms." << std::endl;
  // Inverse order.
  std::cerr << "-- Inversing order" << std::flush;
  Clock::startClock();
  std::deque<Vertex> ordered_vertices; 
  while( ! fp.empty() )
    {
      // reverse order so that greater disks are before smaller disks.
      ordered_vertices.push_front( fp.top().cell );
      fp.pop();
    }
  long t2 = Clock::stopClock();
  std::cerr << " in " << t2 << " ms." << std::endl;
  // Computes representatives.
  std::cerr << "-- Computing all representatives" << std::flush;
  Set disk2_vertices = dsg.emptySet();
  Clock::startClock();
  for ( typename std::deque<Vertex>::const_iterator it = ordered_vertices.begin(), 
	  it_end = ordered_vertices.end();
	it != it_end;
	++it )
    {
      Vertex vtx = *it;
      disk.init( dsg, vtx, myScale );
      disk.computeDisk( -1.0 );
      std::cerr << "  -- vtx=" << vtx << " r=" << disk.radius() << std::endl;
      myDGraph->setProperNeighborhood( vtx, neighborhood );
      VertexSet & reps = myRepresentativesMap[ vtx ];
      // for each representative, or itself if empty.
      if ( reps.size() == 0 )
	{
	  reps.insert( vtx );
	  disk.optimizeBand();
	  myDisks[ vtx ] = disk;
	  myAllRepresentatives.insert( vtx );
	}
      for ( VertexSetConstIterator it = reps.begin(), it_end = reps.end();
	    it != it_end; 
	    ++it )
	{
	  Vertex rvtx = *it;
	  const ComputedDisk & rdisk = myDisks[ rvtx ];
// 	  std::cerr << "    -- rvtx=" << rvtx 
// 		    << " r=" << rdisk.radius()
// 		    << std::endl;
      
	  for ( NeighborhoodConstIterator itn = neighborhood.begin();
		itn != neighborhood.end();
		++itn )
	    {
	      Vertex vtx2 = *itn;
	      VertexSet & reps2 = myRepresentativesMap[ vtx2 ];
	      // We only update neighborhood vertices which do not
	      // have this representative.
	      if ( reps2.find( rvtx ) == reps2.end() )
		{
		  disk2.init( dsg, vtx2, myScale );
		  disk2.computeDisk( -1.0 );
		  if ( disk2.radius() < rdisk.limitRadius() )
		    {
		      disk2.getDiskVertices( disk2_vertices );
		      SetConstIterator it = disk2_vertices.begin();
		      SetConstIterator it_end = disk2_vertices.end();
		      if ( rdisk.areInBand( it, it_end ) )
			{
			  reps2.insert( rvtx );
			}
		    }
		} // end update representative
	    } // end loop on neighborhood
	} // end loop on all representatives
    } // end loop on all vertices
  long t3 = Clock::stopClock();
  std::cerr << " in " << t3 << " ms." << std:: endl;
  // Computes representatives.
  std::cerr << "  -- Listing representatives" << std::endl;
  Clock::startClock();
  for ( VertexSetConstIterator 
	  it = myAllRepresentatives.begin(), 
	  it_end = myAllRepresentatives.end();
	it != it_end;
	++it )
    {
      std::cerr << "    -- rvtx=" << *it << std::endl;
    }
  long t4 = Clock::stopClock();
  std::cerr << "  -- " << myAllRepresentatives.size() 
	    << " reps in " << t4 << " ms." << std:: endl;

  VertexSet debugReps;
  for ( SetConstIterator p = myActiveVertices->begin(); p != myActiveVertices->end(); ++p )
    {
      const VertexSet & reps = representatives( *p );
      for ( VertexSetConstIterator it = reps.begin(), it_end = reps.end();
	    it != it_end; ++it )
	{
	  debugReps.insert( *it );
	}
    }
  std::cerr << "  -- debug representatives has " 
	    << debugReps.size() << " elements." << std::endl;
    
  
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
void 
ImaGene::TangentialCoverDecomposition<TDigitalGraph>::
computeSegmentation( Methods & methods )
{
  if ( myDGraph == 0 ) return;
  const DigitalGraph & dsg = *myDGraph;
  Neighborhood neighborhood;
  NuThickDisk<DigitalGraph> disk;
  NuThickDisk<DigitalGraph> disk2;
  std::vector<double> normalVector(3); 
  PriorityQueue fp;
  std::cerr << "-- Computing disks at scale=" << myScale << std::flush;
  Clock::startClock();
  for ( SetConstIterator p = myActiveVertices->begin(); p != myActiveVertices->end(); ++p )
    {
      Vertex vtx = *p;
      // std::cerr << vtx << std::endl;
      disk.init( dsg, vtx, myScale );
      // progressive computations work !
      disk.computeDisk( -1.0 );
      fp.push( WeightedVertex( vtx, disk.radius(), disk.limitRadius() ) );
    }
  long t1 = Clock::stopClock();
  std::cerr << " in " << t1 << " ms." << std::endl;
  // Inverse order.
  std::cerr << "-- Inversing order" << std::flush;
  Clock::startClock();
  std::deque<Vertex> ordered_vertices; 
  while( ! fp.empty() )
    {
      // reverse order so that greater disks are before smaller disks.
      ordered_vertices.push_front( fp.top().cell );
      fp.pop();
    }
  long t2 = Clock::stopClock();
  std::cerr << " in " << t2 << " ms." << std::endl;
  // Computes representatives.
  std::cerr << "-- Computing all representatives" << std::flush;
  Clock::startClock();
  Set disk2_vertices = dsg.emptySet();
  for ( typename std::deque<Vertex>::const_iterator it = ordered_vertices.begin(), 
	  it_end = ordered_vertices.end();
	it != it_end;
	++it )
    {
      Vertex vtx = *it;
      disk.init( dsg, vtx, myScale );
      disk.computeDisk( -1.0 );
      std::cerr << "  -- vtx=" << vtx << " r=" << disk.radius() << std::endl;
      myDGraph->setProperNeighborhood( vtx, neighborhood );
      VertexSet & reps = myRepresentativesMap[ vtx ];
      // for each representative, or itself if empty.
      if ( reps.size() == 0 )
	{
	  reps.insert( vtx );
	  disk.optimizeBand();
	  myDisks[ vtx ] = disk;
	  myAllRepresentatives.insert( vtx );
	}
      for ( VertexSetConstIterator it = reps.begin(), it_end = reps.end();
	    it != it_end; 
	    ++it )
	{
	  Vertex rvtx = *it;
	  const ComputedDisk & rdisk = myDisks[ rvtx ];
// 	  std::cerr << "    -- rvtx=" << rvtx 
// 		    << " r=" << rdisk.radius()
// 		    << std::endl;
      
	  for ( NeighborhoodConstIterator itn = neighborhood.begin();
		itn != neighborhood.end();
		++itn )
	    {
	      Vertex vtx2 = *itn;
	      VertexSet & reps2 = myRepresentativesMap[ vtx2 ];
	      // We only update neighborhood vertices which do not
	      // have this representative.
	      if ( reps2.size() == 0 )
		//if ( reps2.find( rvtx ) == reps2.end() )
		{
		  disk2.init( dsg, vtx2, myScale );
		  disk2.computeDisk( -1.0 );
		  if ( disk2.radius() < rdisk.limitRadius() )
		    {
		      disk2.getDiskVertices( disk2_vertices );
		      SetConstIterator it = disk2_vertices.begin();
		      SetConstIterator it_end = disk2_vertices.end();
		      if ( rdisk.areInBand( it, it_end ) )
			{
			  reps2.insert( rvtx );
			}
		    }
		} // end update representative
	    } // end loop on neighborhood
	} // end loop on all representatives
    } // end loop on all vertices
  long t3 = Clock::stopClock();
  std::cerr << " in " << t3 << " ms." << std:: endl;
  // Computes representatives.
  std::cerr << "  -- Listing representatives" << std::endl;
  Clock::startClock();
  for ( VertexSetConstIterator 
	  it = myAllRepresentatives.begin(), 
	  it_end = myAllRepresentatives.end();
	it != it_end;
	++it )
    {
      std::cerr << "    -- rvtx=" << *it << std::endl;
    }
  long t4 = Clock::stopClock();
  std::cerr << "  -- " << myAllRepresentatives.size() 
	    << " reps in " << t4 << " ms." << std:: endl;

  VertexSet debugReps;
  for ( SetConstIterator p = myActiveVertices->begin(); p != myActiveVertices->end(); ++p )
    {
      const VertexSet & reps = representatives( *p );
      for ( VertexSetConstIterator it = reps.begin(), it_end = reps.end();
	    it != it_end; ++it )
	{
	  debugReps.insert( *it );
	}
    }
  std::cerr << "  -- debug representatives has " 
	    << debugReps.size() << " elements." << std::endl;
    
  
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
void 
ImaGene::TangentialCoverDecomposition<TDigitalGraph>::
computeAccretion( Methods & methods )
{
  if ( myDGraph == 0 ) return;
  const DigitalGraph & dsg = *myDGraph;
  Neighborhood neighborhood;
  NuThickDisk<DigitalGraph> disk;
  // NuThickDisk<DigitalGraph> disk2;
  std::vector<double> normalVector(3); 
  PriorityQueue fp;
  std::cerr << "-- Computing disks at scale=" << myScale << std::flush;
  Clock::startClock();
  for ( SetConstIterator p = myActiveVertices->begin(); p != myActiveVertices->end(); ++p )
    {
      Vertex vtx = *p;
      // std::cerr << vtx << std::endl;
      disk.init( dsg, vtx, myScale );
      // progressive computations work !
      disk.computeDisk( -1.0 );
      fp.push( WeightedVertex( vtx, disk.radius(), disk.limitRadius() ) );
    }
  long t1 = Clock::stopClock();
  std::cerr << " in " << t1 << " ms." << std::endl;
  // Inverse order.
  std::cerr << "-- Inversing order" << std::flush;
  Clock::startClock();
  std::deque<Vertex> ordered_vertices; 
  while( ! fp.empty() )
    {
      // reverse order so that greater disks are before smaller disks.
      ordered_vertices.push_front( fp.top().cell );
      fp.pop();
    }
  long t2 = Clock::stopClock();
  std::cerr << " in " << t2 << " ms." << std::endl;
  // Computes representatives.
  std::cerr << "-- Computing all representatives" << std::flush;
  
  Clock::startClock();
  Set* ptr_set = new Set( myDGraph->emptySet() );
  Set & disk2_vertices = *ptr_set;
  for ( typename std::deque<Vertex>::const_iterator 
	  it = ordered_vertices.begin(), 
	  it_end = ordered_vertices.end();
	it != it_end;
	++it )
    {
      Vertex vtx = *it;
      VertexSet & reps = myRepresentativesMap[ vtx ];
      if ( reps.size() == 0 )
	{
	  disk.init( dsg, vtx, myScale );
	  disk.computeDisk( -1 );
	  disk.getNormal( normalVector );
	  std::cerr << "  -- vtx=" << vtx << " r=" << disk.radius() 
		    << " N=(" << normalVector[ 0 ]
		    << ", " << normalVector[ 1 ]
		    << ", " << normalVector[ 2 ]
		    << ")" << std::endl;
	  //disk.optimizeBand();
	  Set* extension = new Set( myDGraph->emptySet() );
	  disk.computeExtension( *extension );
	  reps.insert( vtx );
	  myAllRepresentatives.insert( vtx );
	  for ( SetConstIterator 
		  it2 = extension->begin(), it2_end = extension->end();
		it2 != it2_end;
		++it2 )
	    {
	      Vertex vtx2 = *it2;
	      VertexSet & reps2 = myRepresentativesMap[ vtx2 ];
	      // reps2.insert( vtx );

	      NuThickDisk<DigitalGraph> disk2;
	      disk2.init( dsg, vtx2, myScale > 1.0 ? myScale - 1.0 : 0.0 );
	      disk2.computeDisk( -1 );
	      if ( disk2.radius() < disk.limitRadius() )
	      	{
		  disk2.getDiskVertices( disk2_vertices );
	      	  SetConstIterator it3 = disk2_vertices.begin();
	      	  SetConstIterator it3_end = disk2_vertices.end();
	      	  // bool all_inside = true;
	      	  // for ( ; it3 != it3_end; ++it3 )
	      	  //   if ( ! (*extension)[ *it3 ] )
	      	  //     {
	      	  // 	all_inside = false;
	      	  // 	break;
	      	  //     }
	      	  // if ( all_inside )
	      	  //   reps2.insert( vtx );
	      	  if ( disk.areInBand( it3, it3_end ) )
		    reps2.insert( vtx );
	      	}
	    } // end loop on extension of vtx. 
	  delete extension;
	} // end already has representative
    } // end loop on all vertices
  delete ptr_set;
  long t3 = Clock::stopClock();
  std::cerr << " in " << t3 << " ms." << std:: endl;
  // Computes representatives.
  std::cerr << "  -- Listing representatives" << std::endl;
  Clock::startClock();
  for ( VertexSetConstIterator 
	  it = myAllRepresentatives.begin(), 
	  it_end = myAllRepresentatives.end();
	it != it_end;
	++it )
    {
      std::cerr << "    -- rvtx=" << *it << std::endl;
    }
  long t4 = Clock::stopClock();
  std::cerr << "  -- " << myAllRepresentatives.size() 
	    << " reps in " << t4 << " ms." << std:: endl;

  VertexSet debugReps;
  for ( SetConstIterator p = myActiveVertices->begin(); p != myActiveVertices->end(); ++p )
    {
      const VertexSet & reps = representatives( *p );
      for ( VertexSetConstIterator it = reps.begin(), it_end = reps.end();
	    it != it_end; ++it )
	{
	  debugReps.insert( *it );
	}
    }
  std::cerr << "  -- debug representatives has " 
	    << debugReps.size() << " elements." << std::endl;
  //delete extension;
  
}

//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
void 
ImaGene::TangentialCoverDecomposition<TDigitalGraph>::
computeMaximalPlanes( Methods & methods, bool exact )
{
  if ( myDGraph == 0 ) return;
  const DigitalGraph & dsg = *myDGraph;
  Neighborhood neighborhood;
  NuThickDisk<DigitalGraph> disk;
  Set* maximal_plane = new Set( myDGraph->emptySet() );
  std::vector<double> normalVector(3); 
  PriorityQueue fp;
  std::cerr << "-- Computing disks at scale=" << myScale << std::flush;
  Clock::startClock();
  for ( SetConstIterator p = myActiveVertices->begin(),
	  p_end = myActiveVertices->end(); 
	p != p_end; ++p )
    {
      Vertex vtx = *p;
      disk.init( dsg, vtx, myScale );
      disk.computeDisk( -1.0 );
      fp.push( WeightedVertex( vtx, disk.radius(), disk.limitRadius() ) );
    }
  long t1 = Clock::stopClock();
  std::cerr << " in " << t1 << " ms." << std::endl;
  // reverse order so that greater disks are before smaller disks.
  std::cerr << "-- Inversing order" << std::flush;
  Clock::startClock();
  std::deque<Vertex> ordered_vertices; 
  while( ! fp.empty() )
    {
      ordered_vertices.push_front( fp.top().cell );
      fp.pop();
    }
  long t2 = Clock::stopClock();
  std::cerr << " in " << t2 << " ms." << std::endl;

  // Computes representatives.
  std::cerr << "-- Computing all representatives" << std::flush;
  Clock::startClock();
  for ( typename std::deque<Vertex>::const_iterator 
	  it = ordered_vertices.begin(), 
	  it_end = ordered_vertices.end();
	it != it_end;
	++it )
    {
      Vertex vtx = *it;
      VertexSet & reps = myRepresentativesMap[ vtx ];
      if ( reps.size() == 0 )
	{
	  disk.init( dsg, vtx, myScale );
	  disk.computeDisk( -1 );
	  disk.getNormal( normalVector );
	  std::cerr << "  -- vtx=" << vtx << " r=" << disk.radius() 
		    << " N=(" << normalVector[ 0 ]
		    << ", " << normalVector[ 1 ]
		    << ", " << normalVector[ 2 ]
		    << ")" << std::endl;
	  
	  if ( exact ) disk.computeExactMaximalPlane( *maximal_plane );
	  else         disk.computeMaximalPlane( *maximal_plane );
	  reps.insert( vtx );
	  myAllRepresentatives.insert( vtx );
	  for ( SetConstIterator 
		  it2 = maximal_plane->begin(), it2_end = maximal_plane->end();
		it2 != it2_end;
		++it2 )
	    {
	      Vertex vtx2 = *it2;
	      VertexSet & reps2 = myRepresentativesMap[ vtx2 ];
	      reps2.insert( vtx );
	    } // end loop on extension of vtx. 
	} // end already has representative
    } // end loop on all vertices
  long t3 = Clock::stopClock();
  std::cerr << " in " << t3 << " ms." << std:: endl;
  // Computes representatives.
  std::cerr << "  -- Listing representatives" << std::endl;
  Clock::startClock();
  for ( VertexSetConstIterator 
	  it = myAllRepresentatives.begin(), 
	  it_end = myAllRepresentatives.end();
	it != it_end;
	++it )
    {
      std::cerr << "    -- rvtx=" << *it << std::endl;
    }
  long t4 = Clock::stopClock();
  std::cerr << "  -- " << myAllRepresentatives.size() 
	    << " reps in " << t4 << " ms." << std:: endl;

  VertexSet debugReps;
  for ( SetConstIterator p = myActiveVertices->begin(); p != myActiveVertices->end(); ++p )
    {
      const VertexSet & reps = representatives( *p );
      for ( VertexSetConstIterator it = reps.begin(), it_end = reps.end();
	    it != it_end; ++it )
	{
	  debugReps.insert( *it );
	}
    }
  std::cerr << "  -- debug representatives has " 
	    << debugReps.size() << " elements." << std::endl;
  delete maximal_plane;
  
}


//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
void 
ImaGene::TangentialCoverDecomposition<TDigitalGraph>::
clear()
{
  myRepresentativesMap.clear();
  myAllRepresentatives.clear();
  myDisks.clear();
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
const typename ImaGene::TangentialCoverDecomposition<TDigitalGraph>::VertexSet &
ImaGene::TangentialCoverDecomposition<TDigitalGraph>::
representatives( const Vertex & v ) const
{
  typename MapVertexToVertexSet::const_iterator it = 
    myRepresentativesMap.find( v );
  ASSERT_TangentialCoverDecomposition( it != myRepresentativesMap.end() );
  return it->second;
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
const typename ImaGene::TangentialCoverDecomposition<TDigitalGraph>::VertexSet &
ImaGene::TangentialCoverDecomposition<TDigitalGraph>::
allRepresentatives() const
{
  return myAllRepresentatives;
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
void 
ImaGene::TangentialCoverDecomposition<TDigitalGraph>::selfDisplay
( std::ostream& that_stream ) const
{
  that_stream << "[TangentialCoverDecomposition]";
}
//-----------------------------------------------------------------------------
template <typename TDigitalGraph>
inline
bool
ImaGene::TangentialCoverDecomposition<TDigitalGraph>:: 
OK() const
{
  return true;
}



///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions and external operators                 //

/**
 * Overloads 'operator<<' for displaying objects of class 'TangentialCoverDecomposition'.
 * @param that_stream the output stream where the object is written.
 * @param that_object_to_display the object of class 'TangentialCoverDecomposition' to write.
 * @return the output stream after the writing.
 */
template <typename TDigitalGraph>
inline
std::ostream&
ImaGene::operator<<
( std::ostream & that_stream, 
  const TangentialCoverDecomposition<TDigitalGraph> & that_object_to_display )
{
  that_object_to_display.selfDisplay( that_stream );
  return that_stream;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


